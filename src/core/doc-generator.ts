import * as fs from 'fs';
import * as path from 'path';
import { ComponentInfo, DocGeneratorConfig, DocumentationOutput } from '../types';
import { FileScanner } from '../utils/file-scanner';
import { TemplateRenderer } from './template-renderer';

export class DocGenerator {
  private fileScanner: FileScanner;
  private templateRenderer: TemplateRenderer;

  constructor(private config: DocGeneratorConfig) {
    this.fileScanner = new FileScanner(config);
    this.templateRenderer = new TemplateRenderer(config);
  }

  /**
   * Generate documentation for all components
   */
  async generate(): Promise<DocumentationOutput[]> {
    console.log('üîç Scanning for components...');
    const components = await this.fileScanner.scanForComponents();
    
    if (components.length === 0) {
      console.log('‚ö†Ô∏è  No components found matching the pattern');
      return [];
    }

    console.log(`üìù Found ${components.length} components`);
    
    // Ensure output directory exists
    this.ensureOutputDirectory();

    const outputs: DocumentationOutput[] = [];

    for (const component of components) {
      try {
        const output = await this.generateComponentDoc(component);
        outputs.push(output);
        console.log(`‚úÖ Generated documentation for ${component.name}`);
      } catch (error) {
        console.error(`‚ùå Failed to generate docs for ${component.name}:`, error);
      }
    }

    // Generate index file
    await this.generateIndex(components, outputs);

    console.log(`üéâ Documentation generated successfully in ${this.config.outputDir}`);
    return outputs;
  }

  /**
   * Generate documentation for a single component
   */
  private async generateComponentDoc(component: ComponentInfo): Promise<DocumentationOutput> {
    const markdown = await this.templateRenderer.render(component);
    const outputPath = this.getOutputPath(component);

    fs.writeFileSync(outputPath, markdown, 'utf-8');

    return {
      markdown,
      component,
      outputPath
    };
  }

  /**
   * Generate index documentation file
   */
  private async generateIndex(components: ComponentInfo[], outputs: DocumentationOutput[]): Promise<void> {
    const indexPath = path.join(this.config.outputDir, 'README.md');
    
    const indexContent = this.generateIndexContent(components, outputs);
    fs.writeFileSync(indexPath, indexContent, 'utf-8');
  }

  /**
   * Generate content for index file
   */
  private generateIndexContent(components: ComponentInfo[], outputs: DocumentationOutput[]): string {
    const ssrComponents = components.filter(c => c.supportsSSR);
    const clientComponents = components.filter(c => c.supportsClient);
    const pages = components.filter(c => c.type === 'page');
    const regularComponents = components.filter(c => c.type === 'component');

    return `# Documentation

Generated documentation for your Next.js application.

## Overview

- **Total Components**: ${components.length}
- **Pages**: ${pages.length}
- **Components**: ${regularComponents.length}
- **SSR Support**: ${ssrComponents.length} components
- **Client-side**: ${clientComponents.length} components

## Pages

${pages.map(page => `- [${page.name}](./${this.getRelativeDocPath(page)})`).join('\n')}

## Components

${regularComponents.map(comp => `- [${comp.name}](./${this.getRelativeDocPath(comp)})`).join('\n')}

${this.config.includeSSR ? `
## SSR Components

Components that support Server-Side Rendering:

${ssrComponents.map(comp => `- [${comp.name}](./${this.getRelativeDocPath(comp)}) - ${comp.description || 'No description'}`).join('\n')}
` : ''}

${this.config.includeClient ? `
## Client-side Components

Components that require client-side rendering:

${clientComponents.map(comp => `- [${comp.name}](./${this.getRelativeDocPath(comp)}) - ${comp.description || 'No description'}`).join('\n')}
` : ''}

---

*Generated by doc-next-ssr v${require('../../package.json').version}*
`;
  }

  /**
   * Get output file path for component documentation
   */
  private getOutputPath(component: ComponentInfo): string {
    const filename = `${component.name}.md`;
    return path.join(this.config.outputDir, filename);
  }

  /**
   * Get relative documentation path for component
   */
  private getRelativeDocPath(component: ComponentInfo): string {
    return `${component.name}.md`;
  }

  /**
   * Ensure output directory exists
   */
  private ensureOutputDirectory(): void {
    if (!fs.existsSync(this.config.outputDir)) {
      fs.mkdirSync(this.config.outputDir, { recursive: true });
    }
  }
}